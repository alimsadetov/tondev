"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonBinaryBridge = exports.useLibrary = exports.getBridge = exports.ResponseType = void 0;
const errors_1 = require("./errors");
var ResponseType;
(function (ResponseType) {
    ResponseType[ResponseType["Success"] = 0] = "Success";
    ResponseType[ResponseType["Error"] = 1] = "Error";
    ResponseType[ResponseType["Nop"] = 2] = "Nop";
    ResponseType[ResponseType["AppRequest"] = 3] = "AppRequest";
    ResponseType[ResponseType["AppNotify"] = 4] = "AppNotify";
    ResponseType[ResponseType["Custom"] = 100] = "Custom";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
let bridge = undefined;
function getBridge() {
    if (!bridge) {
        throw new errors_1.TonClientError(1, "TON Client binary bridge isn't set.");
    }
    return bridge;
}
exports.getBridge = getBridge;
function useLibrary(loader) {
    if ("createContext" in loader) {
        bridge = loader;
    }
    else {
        bridge = new CommonBinaryBridge(loader);
    }
}
exports.useLibrary = useLibrary;
class BinaryLibraryAdapter {
    constructor(library) {
        this.library = library;
    }
    setResponseParamsHandler(handler) {
        if (handler === undefined) {
            this.library.setResponseHandler(undefined);
        }
        else {
            this.library.setResponseHandler((requestId, paramsJson, responseType, finished) => handler(requestId, paramsJson !== "" ? JSON.parse(paramsJson) : undefined, responseType, finished));
        }
    }
    sendRequestParams(context, requestId, functionName, functionParams) {
        const paramsJson = (functionParams === undefined) || (functionParams === null)
            ? ""
            : JSON.stringify(functionParams, (_, value) => typeof value === "bigint"
                ? (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER
                    ? Number(value)
                    : value.toString())
                : value);
        this.library.sendRequest(context, requestId, functionName, paramsJson);
    }
    createContext(configJson) {
        return this.library.createContext(configJson);
    }
    destroyContext(context) {
        this.library.destroyContext(context);
    }
}
class CommonBinaryBridge {
    constructor(loader) {
        this.loading = undefined;
        this.loadError = undefined;
        this.library = undefined;
        this.requests = new Map();
        this.nextRequestId = 1;
        this.contextCount = 0;
        this.responseHandlerAssigned = false;
        this.loading = [];
        loader().then((library, error) => {
            const saveLoading = this.loading;
            this.loading = undefined;
            if (library) {
                let libraryWithParams = "setResponseParamsHandler" in library
                    ? library
                    : new BinaryLibraryAdapter(library);
                this.library = libraryWithParams;
                saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.resolve(libraryWithParams));
            }
            else {
                this.loadError = error !== null && error !== void 0 ? error : undefined;
                saveLoading === null || saveLoading === void 0 ? void 0 : saveLoading.forEach(x => x.reject(error));
            }
        });
    }
    checkResponseHandler() {
        var _a, _b;
        const mustBeAssigned = (this.contextCount > 0) || (this.requests.size > 0);
        if (this.responseHandlerAssigned !== mustBeAssigned) {
            if (mustBeAssigned) {
                (_a = this.library) === null || _a === void 0 ? void 0 : _a.setResponseParamsHandler((requestId, params, responseType, finished) => this.handleLibraryResponse(requestId, params, responseType, finished));
            }
            else {
                (_b = this.library) === null || _b === void 0 ? void 0 : _b.setResponseParamsHandler();
            }
            this.responseHandlerAssigned = mustBeAssigned;
        }
    }
    createContext(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const lib = this.library || (yield this.loadRequired());
            this.contextCount += 1;
            return CommonBinaryBridge.parseResult(yield lib.createContext(JSON.stringify(config)));
        });
    }
    destroyContext(context) {
        var _a;
        this.contextCount = Math.max(this.contextCount - 1, 0);
        this.checkResponseHandler();
        (_a = this.library) === null || _a === void 0 ? void 0 : _a.destroyContext(context);
    }
    request(context, functionName, functionParams, responseHandler) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const lib = (_a = this.library) !== null && _a !== void 0 ? _a : yield this.loadRequired();
            return new Promise((resolve, reject) => {
                const request = {
                    resolve,
                    reject,
                    responseHandler,
                };
                const requestId = this.generateRequestId();
                this.requests.set(requestId, request);
                this.checkResponseHandler();
                lib.sendRequestParams(context, requestId, functionName, functionParams);
            });
        });
    }
    loadRequired() {
        if (this.library !== undefined) {
            return Promise.resolve(this.library);
        }
        if (this.loadError !== undefined) {
            return Promise.reject(this.loadError);
        }
        if (this.loading === undefined) {
            return Promise.reject(new errors_1.TonClientError(1, "TON Client binary library isn't set."));
        }
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.loading) === null || _a === void 0 ? void 0 : _a.push({
                resolve,
                reject,
            });
        });
    }
    generateRequestId() {
        const id = this.nextRequestId;
        do {
            this.nextRequestId += 1;
            if (this.nextRequestId >= Number.MAX_SAFE_INTEGER) {
                this.nextRequestId = 1;
            }
        } while (this.requests.has(this.nextRequestId));
        return id;
    }
    handleLibraryResponse(requestId, params, responseType, finished) {
        const request = this.requests.get(requestId);
        if (!request) {
            return;
        }
        if (finished) {
            this.requests.delete(requestId);
            this.checkResponseHandler();
        }
        switch (responseType) {
            case ResponseType.Success:
                request.resolve(params);
                break;
            case ResponseType.Error:
                request.reject(params);
                break;
            default:
                const isAppObjectOrCustom = responseType === ResponseType.AppNotify
                    || responseType === ResponseType.AppRequest
                    || responseType >= ResponseType.Custom;
                if (isAppObjectOrCustom && request.responseHandler) {
                    request.responseHandler(params, responseType);
                }
        }
    }
    static parseResult(resultJson) {
        const result = JSON.parse(resultJson);
        if ("error" in result) {
            throw new errors_1.TonClientError(result.error.code, result.error.message, result.error.data);
        }
        return result.result;
    }
}
exports.CommonBinaryBridge = CommonBinaryBridge;
//# sourceMappingURL=bin.js.map